<!DOCTYPE html>

<html lang="zh">
  <head>
    
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>依赖注入与服务定位器（Dependency Injection/Service Location） &mdash; Phalcon 1.3.0 文档</title>
    <link href="../_static/rewrite.css" rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.3.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>

    <script src="../_static/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/docs.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Phalcon 1.3.0 文档" href="../index.html" />
    <link rel="next" title="MVC 架构（The MVC Architecture）" href="mvc.html" />
    <link rel="prev" title="示例列表（List of examples）" href="samples.html" /> 
  </head>
  <body>
    <div id="wrapper">

        <div class="size-wrap">

            <div class="header clear-fix">
                <a class="header-logo" href="http://phalconphp.com"><span class="logo-text">Phalcon</span></a>
                <div class="header-right">
                    <iframe src=""
allowtransparency="true" frameborder="0" scrolling="0" width="152px" height="30px"></iframe>
                </div>
                <ul class="header-nav">
                    <li><a href="http://phalconphp.com/" class="header-nav-link">Home</a></li>
                    <li><a href="http://phalconphp.com/download" class="header-nav-link">Download</a></li>
                    <li><a href="http://forum.phalconphp.com/" class="header-nav-link active">Forum</a></li>
                    <li><a href="http://blog.phalconphp.com/" class="header-nav-link">Blog</a></li>
                    <li><a href="http://phalconphp.com/support" class="header-nav-link">Support</a></li>
                    <li><a href="http://store.phalconphp.com/" class="header-nav-link">Store</a></li>
                    <li><a href="https://github.com/phalcon/cphalcon" class="header-nav-link">GitHub</a></li>
                </ul>
            </div>

        </div>
    <div class="header-line">
      <div class="size-wrap">
        <div class="header-line-title title-white">Documentation</div>
      </div>
    </div>
    <div class="related">
      <ul>
        <li class="right" >
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="mvc.html" title="MVC 架构（The MVC Architecture）"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="samples.html" title="示例列表（List of examples）"
             accesskey="P">上一页</a> |</li>
        <li><a href="http://phalconphp.com">Home</a> &raquo;</li>
        <li><a href="../index.html">Phalcon 1.3.0 文档</a> &raquo;</li> 
      </ul>
    </div>  

      <table width="90%" align="center">
        <tr>
      <td class="primary-box" width="25%" valign="top">
            <div>
            <div id="searchbox" style="">
                <!--<form class="search" action="http://readthedocs.org/search/project/" method="get">
                  <input type="search" name="q" size="25" placeholder="Search">
                  <input type="submit" value="Go">
                  <input type="hidden" name="selected_facets" value="project:">
                </form>-->
                <div style="width:200px;padding:10px">
                  <gcse:searchbox-only></gcse:searchbox-only>
                </div>
                <hr>
            </div>
            </div>
			<!--
            <div style="padding:5px;padding-left:10px">
              <div id="carbonads-container">
                <div class="carbonad"><div id="azcarbon"></div>
                <script type="text/javascript">var z = document.createElement("script"); z.type = "text/javascript"; z.async = true; z.src = "http://engine.carbonads.com/z/56496/azcarbon_2_1_0_VERT"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(z, s);</script>
                </div></div>
            </div>
			-->
            <h3><a href="../index.html">內容目录</a></h3>
            <ul>
<li><a class="reference internal" href="#">依赖注入与服务定位器（Dependency Injection/Service Location）</a><ul>
<li><a class="reference internal" href="#our-approach">实现方法（Our approach）</a></li>
<li><a class="reference internal" href="#registering-services-in-the-container">使用容器注册服务（Registering services in the Container）</a><ul>
<li><a class="reference internal" href="#simple-registration">简单的注册（Simple Registration）</a><ul>
<li><a class="reference internal" href="#string">字符串(String)</a></li>
<li><a class="reference internal" href="#object">对象（Object）</a></li>
<li><a class="reference internal" href="#closures-anonymous-functions">闭包与匿名函数（Closures/Anonymous functions）</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-registration">复杂的注册（Complex Registration）</a><ul>
<li><a class="reference internal" href="#constructor-injection">构造函数注入（Constructor Injection）</a></li>
<li><a class="reference internal" href="#setter-injection">设值注入（Setter Injection）</a></li>
<li><a class="reference internal" href="#properties-injection">属性注入（Properties Injection）</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#resolving-services">服务解疑（Resolving Services）</a></li>
<li><a class="reference internal" href="#shared-services">共享服务（Shared services）</a></li>
<li><a class="reference internal" href="#manipulating-services-individually">单独操作服务（Manipulating services individually）</a></li>
<li><a class="reference internal" href="#instantiating-classes-via-the-service-container">通过服务容器实例化类（Instantiating classes via the Service Container）</a></li>
<li><a class="reference internal" href="#di-automatic-injecting-of-the-di-itself">自动注入 DI（Automatic Injecting of the DI itself）</a></li>
<li><a class="reference internal" href="#avoiding-service-resolution">避免服务解析（Avoiding service resolution）</a></li>
<li><a class="reference internal" href="#organizing-services-in-files">使用文件组织服务（Organizing services in files）</a></li>
<li><a class="reference internal" href="#accessing-the-di-in-a-static-way">使用静态的方式访问注入器（Accessing the DI in a static way）</a></li>
<li><a class="reference internal" href="#factory-default-di">注入器默认工厂（Factory Default DI）</a></li>
<li><a class="reference internal" href="#service-name-conventions">服务名称约定（Service Name Conventions）</a></li>
<li><a class="reference internal" href="#implementing-your-own-di">自定义注入器（Implementing your own DI）</a></li>
</ul>
</li>
</ul>

            <h4>上一个主题</h4>
            <p class="topless"><a href="samples.html" title="上一章">&lt; 示例列表（List of examples）</a></p>
            <h4>下一个主题</h4>
            <p class="topless"><a href="mvc.html" title="下一章">MVC 架构（The MVC Architecture） &gt;</a></p>
            <h3>本页</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/reference/di.txt" rel="nofollow">显示源代码</a></li>
            </ul>
        </td>
          <td class="second-box" valign="top">
            <div class="document">
                <div class="documentwrapper">
                  <div class="bodywrapper">
                    <div class="body" >
                      
  <div class="section" id="dependency-injection-service-location">
<h1>依赖注入与服务定位器（Dependency Injection/Service Location）<a class="headerlink" href="#dependency-injection-service-location" title="永久链接至标题">¶</a></h1>
<p>接下来的例子有些长，但解释了为什么我们使用依赖注入与服务定位器.
首先，假设我们正在开发一个组件，叫SomeComponent，它执行的内容现在还不重要。
我们的组件需要依赖数据库的连接。</p>
<p>在下面第一个例子中，数据库的连接是在组件内部建立的。这种方法是不实用的；事实上这样做的话，我们不能改变创建数据库连接的参数或者选择不同的数据库系统，因为连接是当组件被创建时建立的。</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="sd">/**</span>
<span class="sd">     * 连接数据库的实例是被写死在组件的内部</span>
<span class="sd">     * 因此，我们很难从外部替换或者改变它的行为</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">someDbTask</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$connection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
            <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span>
            <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;secret&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;invo&quot;</span>
        <span class="p">));</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="nv">$some</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeComponent</span><span class="p">();</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">someDbTask</span><span class="p">();</span>
</pre></div>
</div>
<p>为了解决这样的情况，我们建立一个setter，在使用前注入独立外部依赖。现在，看起来似乎是一个不错的解决办法：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_connection</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * 设置外部传入的数据库的连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setConnection</span><span class="p">(</span><span class="nv">$connection</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_connection</span> <span class="o">=</span> <span class="nv">$connection</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">someDbTask</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$connection</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_connection</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="nv">$some</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeComponent</span><span class="p">();</span>

<span class="c1">//建立数据库连接实例</span>
<span class="nv">$connection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
    <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span>
    <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
    <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;secret&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;invo&quot;</span>
<span class="p">));</span>

<span class="c1">//向组件注入数据连接实例</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setConnection</span><span class="p">(</span><span class="nv">$connection</span><span class="p">);</span>

<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">someDbTask</span><span class="p">();</span>
</pre></div>
</div>
<p>想一下，假设我们使用这个组件在应用内的好几个地方都用到，然而我们在注入连接实例时还需要建立好几次数据的连接实例。
如果我们可以获取到数据库的连接实例而不用每次都要创建新的连接实例，使用某种全局注册表可以解决这样的问题：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">Registry</span>
<span class="p">{</span>

    <span class="sd">/**</span>
<span class="sd">     * 返回数据库连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getConnection</span><span class="p">()</span>
    <span class="p">{</span>
       <span class="k">return</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
            <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span>
            <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;secret&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;invo&quot;</span>
        <span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_connection</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * 设置外部传入的数据库的连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setConnection</span><span class="p">(</span><span class="nv">$connection</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_connection</span> <span class="o">=</span> <span class="nv">$connection</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">someDbTask</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$connection</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_connection</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="nv">$some</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeComponent</span><span class="p">();</span>

<span class="c1">//把注册表中的连接实例传递给组件</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setConnection</span><span class="p">(</span><span class="nx">Registry</span><span class="o">::</span><span class="na">getConnection</span><span class="p">());</span>

<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">someDbTask</span><span class="p">();</span>
</pre></div>
</div>
<p>现在，让我们设想一下，我们必须实现2个方法，第一个方法是总是创建一个新的连接，第二方法是总是使用一个共享连接：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">Registry</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="k">static</span> <span class="nv">$_connection</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * 建立一个新的连接实例</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">_createConnection</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
            <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span>
            <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
            <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;secret&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;invo&quot;</span>
        <span class="p">));</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 只建立一个连接实例，后面的请求只返回该连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getSharedConnection</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$_connection</span><span class="o">===</span><span class="k">null</span><span class="p">){</span>
            <span class="nv">$connection</span> <span class="o">=</span> <span class="nx">self</span><span class="o">::</span><span class="na">_createConnection</span><span class="p">();</span>
            <span class="nx">self</span><span class="o">::</span><span class="nv">$_connection</span> <span class="o">=</span> <span class="nv">$connection</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$_connection</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 总是返回一个新的连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getNewConnection</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="na">_createConnection</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_connection</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * 设置外部传入的数据库的连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setConnection</span><span class="p">(</span><span class="nv">$connection</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_connection</span> <span class="o">=</span> <span class="nv">$connection</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 这个方法总是需要共享连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">someDbTask</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$connection</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_connection</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * 这个方法总是需要新的连接实例</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">someOtherDbTask</span><span class="p">(</span><span class="nv">$connection</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

<span class="p">}</span>

<span class="nv">$some</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeComponent</span><span class="p">();</span>

<span class="c1">//注入共享连接实例</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setConnection</span><span class="p">(</span><span class="nx">Registry</span><span class="o">::</span><span class="na">getSharedConnection</span><span class="p">());</span>

<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">someDbTask</span><span class="p">();</span>

<span class="c1">//这里我们总是传递一个新的连接实例</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">someOtherDbTask</span><span class="p">(</span><span class="nx">Registry</span><span class="o">::</span><span class="na">getConnection</span><span class="p">());</span>
</pre></div>
</div>
<p>到目前为止，我们已经看到依赖注入怎么解决我们的问题了。把依赖作为参数来传递，而不是建立在内部建立它们，这使我们的应用更加容易维护和更加解耦。不管怎么样，长期来说，这种形式的依赖注入有一些缺点。</p>
<p>例如，如果这个组件有很多依赖，
我们需要创建多个参数的setter方法​​来传递依赖关系，或者建立一个多个参数的构造函数来传递它们，另外在使用组件前还要每次都创建依赖，这让我们的代码像这样不易维护：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">//创建依赖实例或从注册表中查找</span>
<span class="nv">$connection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">();</span>
<span class="nv">$session</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Session</span><span class="p">();</span>
<span class="nv">$fileSystem</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileSystem</span><span class="p">();</span>
<span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Filter</span><span class="p">();</span>
<span class="nv">$selector</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Selector</span><span class="p">();</span>

<span class="c1">//把实例作为参数传递给构造函数</span>
<span class="nv">$some</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeComponent</span><span class="p">(</span><span class="nv">$connection</span><span class="p">,</span> <span class="nv">$session</span><span class="p">,</span> <span class="nv">$fileSystem</span><span class="p">,</span> <span class="nv">$filter</span><span class="p">,</span> <span class="nv">$selector</span><span class="p">);</span>

<span class="c1">// ... 或者使用setter</span>

<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setConnection</span><span class="p">(</span><span class="nv">$connection</span><span class="p">);</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setSession</span><span class="p">(</span><span class="nv">$session</span><span class="p">);</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setFileSystem</span><span class="p">(</span><span class="nv">$fileSystem</span><span class="p">);</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setFilter</span><span class="p">(</span><span class="nv">$filter</span><span class="p">);</span>
<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">setSelector</span><span class="p">(</span><span class="nv">$selector</span><span class="p">);</span>
</pre></div>
</div>
<p>假设我们必须在应用的不同地方使用和创建这些对象。如果当你永远不需要任何依赖实例时，你需要去删掉构造函数的参数，或者去删掉注入的setter。为了解决这样的问题，我们再次回到全局注册表创建组件。不管怎么样，在创建对象之前，它增加了一个新的抽象层：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="c1">// ...</span>

    <span class="sd">/**</span>
<span class="sd">     * Define a factory method to create SomeComponent instances injecting its dependencies</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">factory</span><span class="p">()</span>
    <span class="p">{</span>

        <span class="nv">$connection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">();</span>
        <span class="nv">$session</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Session</span><span class="p">();</span>
        <span class="nv">$fileSystem</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileSystem</span><span class="p">();</span>
        <span class="nv">$filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Filter</span><span class="p">();</span>
        <span class="nv">$selector</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Selector</span><span class="p">();</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nx">self</span><span class="p">(</span><span class="nv">$connection</span><span class="p">,</span> <span class="nv">$session</span><span class="p">,</span> <span class="nv">$fileSystem</span><span class="p">,</span> <span class="nv">$filter</span><span class="p">,</span> <span class="nv">$selector</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>瞬间，我们又回到刚刚开始的问题了，我们再次创建依赖实例在组件内部！我们可以继续前进，找出一个每次能奏效的方法去解决这个问题。但似乎一次又一次，我们又回到了不实用的例子中。</p>
<p>一个实用和优雅的解决方法，是为依赖实例提供一个容器。这个容器担任全局的注册表，就像我们刚才看到的那样。使用依赖实例的容器作为一个桥梁来获取依赖实例，使我们能够降低我们的组件的复杂性：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_di</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nv">$di</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_di</span> <span class="o">=</span> <span class="nv">$di</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">someDbTask</span><span class="p">()</span>
    <span class="p">{</span>

        <span class="c1">// 获得数据库连接实例</span>
        <span class="c1">// 总是返回一个新的连接</span>
        <span class="nv">$connection</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;db&#39;</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">someOtherDbTask</span><span class="p">()</span>
    <span class="p">{</span>

        <span class="c1">// 获得共享连接实例</span>
        <span class="c1">// 每次请求都返回相同的连接实例</span>
        <span class="nv">$connection</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_di</span><span class="o">-&gt;</span><span class="na">getShared</span><span class="p">(</span><span class="s1">&#39;db&#39;</span><span class="p">);</span>

        <span class="c1">// 这个方法也需要一个输入过滤的依赖服务</span>
        <span class="nv">$filter</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;filter&#39;</span><span class="p">);</span>

    <span class="p">}</span>

<span class="p">}</span>

<span class="nv">$di</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Phalcon\DI</span><span class="p">();</span>

<span class="c1">//在容器中注册一个db服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;db&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Connection</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
        <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span>
        <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
        <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;secret&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;invo&quot;</span>
    <span class="p">));</span>
<span class="p">});</span>

<span class="c1">//在容器中注册一个filter服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;filter&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Filter</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">//在容器中注册一个session服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Session</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">//把传递服务的容器作为唯一参数传递给组件</span>
<span class="nv">$some</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeComponent</span><span class="p">(</span><span class="nv">$di</span><span class="p">);</span>

<span class="nv">$some</span><span class="o">-&gt;</span><span class="na">someTask</span><span class="p">();</span>
</pre></div>
</div>
<p>这个组件现在可以很简单的获取到它所需要的服务，服务采用延迟加载的方式，只有在需要使用的时候才初始化，这也节省了服务器资源。这个组件现在是高度解耦。例如，我们可以替换掉创建连接的方式，它们的行为或它们的任何其他方面，也不会影响该组件。</p>
<div class="section" id="our-approach">
<h2>实现方法（Our approach）<a class="headerlink" href="#our-approach" title="永久链接至标题">¶</a></h2>
<p>Phalcon\DI 是一个实现依赖注入和定位服务的组件，而且它本身就是一个装载它们的容器。</p>
<p>因为Phalcon是高度解构的，整合框架的不同组件，使用Phalcon\DI是必不可少的。开发者也可以使用这个组件去注入依赖和管理的应用程序中来自不同类的全局实例。</p>
<p>基本上，这个组件实现了 [控制反转](<a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">http://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC</a>) 的模式。使用这种模式，组件的对象不用再使用setter或者构造函数去接受依赖实例，而是使用请求服务的依赖注入。这减少了总的复杂性，因为在组件内，只有一个方法去获取所需的依赖实例。</p>
<p>另外，该模式增加了代码的可测试性，从而使其不易出错。</p>
</div>
<div class="section" id="registering-services-in-the-container">
<h2>使用容器注册服务（Registering services in the Container）<a class="headerlink" href="#registering-services-in-the-container" title="永久链接至标题">¶</a></h2>
<p>框架本身或者开发者都可以注册服务。当一个组件A需要组件B(或者它的类的实例) 去操作，它可以通过容器去请求组件B，而不是创建一个新的组件B实例。</p>
<p>这个工作方法给我们提供了许多优势：</p>
<ul class="simple">
<li>我们可以很容易的使用一个我们自己建立的或者是第三方的组件去替换原有的组件。</li>
<li>我们完全控制对象的初始化，这让我们在传递它们的实例到组件之前，根据需要设置这些对象。</li>
<li>我们可以在一个结构化的和统一组件内获取全局实例。</li>
</ul>
<p>服务可以使用不同方式去定义：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 创建一个依赖注入容器</span>
<span class="nv">$di</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Phalcon\DI</span><span class="p">();</span>

<span class="c1">// 通过类名称设置服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s2">&quot;request&quot;</span><span class="p">,</span> <span class="s1">&#39;Phalcon\Http\Request&#39;</span><span class="p">);</span>

<span class="c1">// 使用匿名函数去设置服务，这个实例将被延迟加载</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s2">&quot;request&quot;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Phalcon\Http\Request</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// 直接注册一个实例</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s2">&quot;request&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Phalcon\Http\Request</span><span class="p">());</span>

<span class="c1">// 使用数组方式定义服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s2">&quot;request&quot;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s2">&quot;className&quot;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Phalcon\Http\Request&#39;</span>
<span class="p">));</span>
</pre></div>
</div>
<p>使用数组的方式去注册服务也是可以的：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 创建一个依赖注入容器</span>
<span class="nv">$di</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Phalcon\DI</span><span class="p">();</span>

<span class="c1">// 通过类名称设置服务</span>
<span class="nv">$di</span><span class="p">[</span><span class="s2">&quot;request&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Phalcon\Http\Request&#39;</span><span class="p">;</span>

<span class="c1">// 使用匿名函数去设置服务，这个实例将被延迟加载</span>
<span class="nv">$di</span><span class="p">[</span><span class="s2">&quot;request&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Phalcon\Http\Request</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// 直接注册一个实例</span>
<span class="nv">$di</span><span class="p">[</span><span class="s2">&quot;request&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Phalcon\Http\Request</span><span class="p">();</span>

<span class="c1">// 使用数组方式定义服务</span>
<span class="nv">$di</span><span class="p">[</span><span class="s2">&quot;request&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
    <span class="s2">&quot;className&quot;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Phalcon\Http\Request&#39;</span>
<span class="p">);</span>
</pre></div>
</div>
<p>在上面的例子中，当框架需要访问request服务的内容，它会在容器里面查找名为‘request’的服务。
在容器中将返回所需要的服务的实例。当有需要时，开发者可能最终需要替换这个组件。</p>
<p>每个方法（在上面的例子证明）用于设置/注册服务方面具都具有优势和劣势。这是由开发者和特别的要求决定具体使用哪个。</p>
<p>通过字符串设置一个服务是很简单，但是缺乏灵活性。通过数组设置服务提供了更加灵活的方式，但是使代码更复杂。匿名函数是上述两者之间的一个很好的平衡，但是会导致比预期的更多维护。</p>
<p>Phalcon\DI 对每个储存的服务提供了延迟加载。除非开发者选择直接实例化一个对象并将其存储在容器中，任何储存在里面的对象(通过数组，字符串等等设置的)都将延迟加载，即只要当使用到时才实例化。</p>
<div class="section" id="simple-registration">
<h3>简单的注册（Simple Registration）<a class="headerlink" href="#simple-registration" title="永久链接至标题">¶</a></h3>
<p>就像你之前看到的那样，这里有几种方法去注册服务。下面是简单调用的例子：</p>
<div class="section" id="string">
<h4>字符串(String)<a class="headerlink" href="#string" title="永久链接至标题">¶</a></h4>
<p>使用字符串注册服务需要一个有效的类名称，它将返回指定的类对象，如果类还没有加载的话，将使用自动加载器实例化对象。这种类型不允许向构造函数指定参数：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 返回 new Phalcon\Http\Request(); 对象</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="s1">&#39;Phalcon\Http\Request&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="object">
<h4>对象（Object）<a class="headerlink" href="#object" title="永久链接至标题">¶</a></h4>
<p>这种类型注册服务需要一个对象。实际上，这个服务不再需要初始化，因为它已经是一个对象，可以说，这是不是一个真正的依赖注入，但是如果你想强制总是返回相同的对象/值，使用这种方式还是有用的:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 返回 Phalcon\Http\Request(); 对象</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Phalcon\Http\Request</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="closures-anonymous-functions">
<h4>闭包与匿名函数（Closures/Anonymous functions）<a class="headerlink" href="#closures-anonymous-functions" title="永久链接至标题">¶</a></h4>
<p>这个方法提供了更加自由的方式去注册依赖，但是如果你想从外部改变实例化的参数而不用改变注册服务的代码，这是很困难的：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s2">&quot;db&quot;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">\Phalcon\Db\Adapter\Pdo\Mysql</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
         <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;localhost&quot;</span><span class="p">,</span>
         <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
         <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;secret&quot;</span><span class="p">,</span>
         <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;blog&quot;</span>
    <span class="p">));</span>
<span class="p">});</span>
</pre></div>
</div>
<p>这些限制是可以克服的，通过传递额外的变量到闭包函数里面：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 把当前域的$config变量传递给匿名函数使用</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s2">&quot;db&quot;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="k">use</span> <span class="p">(</span><span class="nv">$config</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">\Phalcon\Db\Adapter\Pdo\Mysql</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
         <span class="s2">&quot;host&quot;</span> <span class="o">=&gt;</span> <span class="nv">$config</span><span class="o">-&gt;</span><span class="na">host</span><span class="p">,</span>
         <span class="s2">&quot;username&quot;</span> <span class="o">=&gt;</span> <span class="nv">$config</span><span class="o">-&gt;</span><span class="na">username</span><span class="p">,</span>
         <span class="s2">&quot;password&quot;</span> <span class="o">=&gt;</span> <span class="nv">$config</span><span class="o">-&gt;</span><span class="na">password</span><span class="p">,</span>
         <span class="s2">&quot;dbname&quot;</span> <span class="o">=&gt;</span> <span class="nv">$config</span><span class="o">-&gt;</span><span class="na">name</span>
    <span class="p">));</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="complex-registration">
<h3>复杂的注册（Complex Registration）<a class="headerlink" href="#complex-registration" title="永久链接至标题">¶</a></h3>
<p>如果要求不用实例化/解析服务，就可以改变定义服务的话，我们需要使用数组的方式去定义服务。使用数组去定义服务可以更加详细：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 通过类名和参数，注册logger服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Phalcon\Logger\Adapter\File&#39;</span><span class="p">,</span>
    <span class="s1">&#39;arguments&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parameter&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;../apps/logs/error.log&#39;</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">));</span>

<span class="c1">// 使用匿名函数的方式</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">\Phalcon\Logger\Adapter\File</span><span class="p">(</span><span class="s1">&#39;../apps/logs/error.log&#39;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>上面两种注册服务的方式的结果是一样的。然而，使用数组定义的话，在需要的时候可以变更注册服务的参数：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 改变logger服务的类名</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">getService</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">setClassName</span><span class="p">(</span><span class="s1">&#39;MyCustomLogger&#39;</span><span class="p">);</span>

<span class="c1">// 不用实例化就可以改变第一个参数值</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">getService</span><span class="p">(</span><span class="s1">&#39;logger&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">setParameter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parameter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;../apps/logs/error.log&#39;</span>
<span class="p">));</span>
</pre></div>
</div>
<p>除了使用数组的语法注册服务，你还可以使用以下三种类型的依赖注入：</p>
<div class="section" id="constructor-injection">
<h4>构造函数注入（Constructor Injection）<a class="headerlink" href="#constructor-injection" title="永久链接至标题">¶</a></h4>
<p>这个注入方式是通过传递依赖/参数到类的构造函数。让我们假设我们有下面的组件：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">SomeApp</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Phalcon\Http\Response</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_response</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$_someFlag</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">(</span><span class="nx">Response</span> <span class="nv">$response</span><span class="p">,</span> <span class="nv">$someFlag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_response</span> <span class="o">=</span> <span class="nv">$response</span><span class="p">;</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_someFlag</span> <span class="o">=</span> <span class="nv">$someFlag</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>这个服务可以这样被注入：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;response&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Phalcon\Http\Response&#39;</span>
<span class="p">));</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;someComponent&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;SomeApp\SomeComponent&#39;</span><span class="p">,</span>
    <span class="s1">&#39;arguments&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="k">array</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;service&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;response&#39;</span><span class="p">),</span>
        <span class="k">array</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parameter&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">));</span>
</pre></div>
</div>
<p>reponse服务(Phalcon\Http\Response)作为第一个参数传递给构造函数，与此同时，一个布尔类型的值(true)作为第二个参数传递。</p>
</div>
<div class="section" id="setter-injection">
<h4>设值注入（Setter Injection）<a class="headerlink" href="#setter-injection" title="永久链接至标题">¶</a></h4>
<p>类中可能有setter去注入可选的依赖，前面那个class可以修改成通过setter来注入依赖的方式：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">SomeApp</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Phalcon\Http\Response</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_response</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$_someFlag</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">setResponse</span><span class="p">(</span><span class="nx">Response</span> <span class="nv">$response</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_response</span> <span class="o">=</span> <span class="nv">$response</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">setFlag</span><span class="p">(</span><span class="nv">$someFlag</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_someFlag</span> <span class="o">=</span> <span class="nv">$someFlag</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>用setter方式来注入的服务可以通过下面的方式来注册：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;response&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Phalcon\Http\Response&#39;</span>
<span class="p">));</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;someComponent&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;SomeApp\SomeComponent&#39;</span><span class="p">,</span>
    <span class="s1">&#39;calls&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;method&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;setResponse&#39;</span><span class="p">,</span>
            <span class="s1">&#39;arguments&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
                <span class="k">array</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;service&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;response&#39;</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;method&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;setFlag&#39;</span><span class="p">,</span>
            <span class="s1">&#39;arguments&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
                <span class="k">array</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parameter&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="properties-injection">
<h4>属性注入（Properties Injection）<a class="headerlink" href="#properties-injection" title="永久链接至标题">¶</a></h4>
<p>这是一个不太常用的方式，这种方式的注入是通过类的public属性来注入：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">namespace</span> <span class="nx">SomeApp</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Phalcon\Http\Response</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">public</span> <span class="nv">$response</span><span class="p">;</span>

    <span class="k">public</span> <span class="nv">$someFlag</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>通过属性注入的服务，可以像下面这样注册：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;response&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;Phalcon\Http\Response&#39;</span>
<span class="p">));</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;someComponent&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;className&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;SomeApp\SomeComponent&#39;</span><span class="p">,</span>
    <span class="s1">&#39;properties&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;response&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;service&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;response&#39;</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;name&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;someFlag&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;parameter&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">));</span>
</pre></div>
</div>
<p>支持包括下面的参数类型：</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="37%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">type</th>
<th class="head">描述</th>
<th class="head">例子</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>parameter</td>
<td>表示一个文本值作为参数传递过去</td>
<td>array(&#8216;type&#8217; =&gt; &#8216;parameter&#8217;, &#8216;value&#8217; =&gt; 1234)</td>
</tr>
<tr class="row-odd"><td>service</td>
<td>表示作为服务</td>
<td>array(&#8216;type&#8217; =&gt; &#8216;service&#8217;, &#8216;name&#8217; =&gt; &#8216;request&#8217;)</td>
</tr>
<tr class="row-even"><td>instance</td>
<td>表示必须动态生成的对象</td>
<td>array(&#8216;type&#8217; =&gt; &#8216;instance&#8217;, &#8216;className&#8217; =&gt; &#8216;DateTime&#8217;, &#8216;arguments&#8217; =&gt; array(&#8216;now&#8217;))</td>
</tr>
</tbody>
</table>
<p>解析一个定义复杂的服务也许性能上稍微慢于先前看到的简单定义。但是，这提供了一个更强大的方式来定义和注入服务。</p>
<p>混合不同类型的定义是可以的，每个人可以应用需要决定什么样的注册服务的方式是最适当的。</p>
</div>
</div>
</div>
<div class="section" id="resolving-services">
<h2>服务解疑（Resolving Services）<a class="headerlink" href="#resolving-services" title="永久链接至标题">¶</a></h2>
<p>从容器中获取一个服务是一件简单的事情，只要通过“get”方法就可以。这将返回一个服务的新实例：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="nv">$request</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s2">&quot;request&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>或者通过魔术方法的方式获取：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">();</span>
</pre></div>
</div>
<p>或者通过访问数组的方式获取：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$di</span><span class="p">[</span><span class="s1">&#39;request&#39;</span><span class="p">];</span>
</pre></div>
</div>
<p>参数可以传递到构造函数中，通过添加一个数组的参数到get方法中：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 将返回：new MyComponent(&quot;some-parameter&quot;, &quot;other&quot;)</span>
<span class="nv">$component</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s2">&quot;MyComponent&quot;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s2">&quot;some-parameter&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="shared-services">
<h2>共享服务（Shared services）<a class="headerlink" href="#shared-services" title="永久链接至标题">¶</a></h2>
<p>服务可以注册成“shared”类型的服务，这意味着这个服务将使用 [单例模式](<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F</a>) 运行，
一旦服务被首次解析后，这个实例将被保存在容器中，之后的每次请求都在容器中查找并返回这个实例</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 把session服务注册成“shared”类型</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">setShared</span><span class="p">(</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">$session</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Phalcon\Session\Adapter\Files</span><span class="p">();</span>
    <span class="nv">$session</span><span class="o">-&gt;</span><span class="na">start</span><span class="p">();</span>
    <span class="k">return</span> <span class="nv">$session</span><span class="p">;</span>
<span class="p">});</span>

<span class="nv">$session</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;session&#39;</span><span class="p">);</span> <span class="c1">// 第一次获取session服务时，session服务将实例化</span>
<span class="nv">$session</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">getSession</span><span class="p">();</span> <span class="c1">// 第二次获取时，不再实例化，直接返回第一次实例化的对象</span>
</pre></div>
</div>
<p>另一种方式去注册一个“shared”类型的服务是，传递“set”服务的时候，把true作为第三个参数传递过去：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 把session服务注册成“shared”类型</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">},</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p>如果一个服务不是注册成“shared”类型，而你又想从DI中获取服务的“shared”实例，你可以使用getShared方法：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">getShared</span><span class="p">(</span><span class="s2">&quot;request&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="manipulating-services-individually">
<h2>单独操作服务（Manipulating services individually）<a class="headerlink" href="#manipulating-services-individually" title="永久链接至标题">¶</a></h2>
<p>一旦服务被注册到服务容器中，你可以单独操作它：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 注册request服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">,</span> <span class="s1">&#39;Phalcon\Http\Request&#39;</span><span class="p">);</span>

<span class="c1">// 获取服务</span>
<span class="nv">$requestService</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">getService</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">);</span>

<span class="c1">// 改变它的定义</span>
<span class="nv">$requestService</span><span class="o">-&gt;</span><span class="na">setDefinition</span><span class="p">(</span><span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Phalcon\Http\Request</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// 修改成shared类型</span>
<span class="nv">$requestService</span><span class="o">-&gt;</span><span class="na">setShared</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>

<span class="c1">// 解析服务（返回Phalcon\Http\Request实例）</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$requestService</span><span class="o">-&gt;</span><span class="na">resolve</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="instantiating-classes-via-the-service-container">
<h2>通过服务容器实例化类（Instantiating classes via the Service Container）<a class="headerlink" href="#instantiating-classes-via-the-service-container" title="永久链接至标题">¶</a></h2>
<p>当你从服务容器中请求一个服务，如果找不到具有相同名称的服务，它将尝试去加载以这个服务为名称的类。利用这个的行为，
我们可以代替任意一个类，通过简单的利用服务的名称来注册：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">// 把一个控制器注册为服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;IndexController&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nv">$component</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Component</span><span class="p">();</span>
    <span class="k">return</span> <span class="nv">$component</span><span class="p">;</span>
<span class="p">},</span> <span class="k">true</span><span class="p">);</span>

<span class="c1">// 把一个控制器注册为服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;MyOtherComponent&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 实际上返回另外一个组件</span>
    <span class="nv">$component</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AnotherComponent</span><span class="p">();</span>
    <span class="k">return</span> <span class="nv">$component</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 获取通过服务容器创建的对象</span>
<span class="nv">$myComponent</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;MyOtherComponent&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>你可以利用这种方式，通过服务容器来总是实例化你的类(即是他们没有注册为服务)，
DI会回退到一个有效的自动加载类中，去加载这个类。通过这样做，以后你可以轻松替换任意的类通过为它实现一个定义。</p>
</div>
<div class="section" id="di-automatic-injecting-of-the-di-itself">
<h2>自动注入 DI（Automatic Injecting of the DI itself）<a class="headerlink" href="#di-automatic-injecting-of-the-di-itself" title="永久链接至标题">¶</a></h2>
<p>如果一个类或者组件需要用到DI服务，你需要在你的类中实现 <a class="reference internal" href="../api/Phalcon_DI_InjectionAwareInterface.html"><em>Phalcon\DI\InjectionAwareInterface</em></a> 接口，
这样就可以在实例化这个类的对象时自动注入DI的服务:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">MyClass</span> <span class="k">implements</span> <span class="nx">\Phalcon\DI\InjectionAwareInterface</span>
<span class="p">{</span>

    <span class="k">protected</span> <span class="nv">$_di</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">setDi</span><span class="p">(</span><span class="nv">$di</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_di</span> <span class="o">=</span> <span class="nv">$di</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getDi</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">_di</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>按照上面这样，一旦服务被解析，$di对象将自动传递到setDi()方法：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">//注册服务</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;myClass&#39;</span><span class="p">,</span> <span class="s1">&#39;MyClass&#39;</span><span class="p">);</span>

<span class="c1">//解析服务（注意：将自动调用$myClass-&gt;setDi($di)方法）</span>
<span class="nv">$myClass</span> <span class="o">=</span> <span class="nv">$di</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;myClass&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="avoiding-service-resolution">
<h2>避免服务解析（Avoiding service resolution）<a class="headerlink" href="#avoiding-service-resolution" title="永久链接至标题">¶</a></h2>
<p>一些服务是用于应用的每个请求中，通过消除解析服务的过程的方式，可以使得服务解析在性能上会有小小的提升：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="c1">//外部解析服务对象而不是使用定义服务的方式</span>
<span class="nv">$router</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyRouter</span><span class="p">();</span>

<span class="c1">//把已解析的对象设置到注册服务中</span>
<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;router&#39;</span><span class="p">,</span> <span class="nv">$router</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="organizing-services-in-files">
<h2>使用文件组织服务（Organizing services in files）<a class="headerlink" href="#organizing-services-in-files" title="永久链接至标题">¶</a></h2>
<p>你可以更好的组织你的应用，通过移动注册的服务到独立的文件里面，而不是全部写在应用的引导文件中：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$di</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;router&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">include</span> <span class="s2">&quot;../app/config/routes.php&quot;</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>这样，在文件(&#8221;../app/config/routes.php&#8221;)中，返回已解析的对象：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="nv">$router</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyRouter</span><span class="p">();</span>

<span class="nv">$router</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">);</span>

<span class="k">return</span> <span class="nv">$router</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-the-di-in-a-static-way">
<h2>使用静态的方式访问注入器（Accessing the DI in a static way）<a class="headerlink" href="#accessing-the-di-in-a-static-way" title="永久链接至标题">¶</a></h2>
<p>如果需要的话，你可以访问最新创建的DI对象，通过下面这种静态方法的方式：</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">SomeComponent</span>
<span class="p">{</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">someMethod</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//获取session服务</span>
        <span class="nv">$session</span> <span class="o">=</span> <span class="nx">Phalcon\DI</span><span class="o">::</span><span class="na">getDefault</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">getSession</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="factory-default-di">
<h2>注入器默认工厂（Factory Default DI）<a class="headerlink" href="#factory-default-di" title="永久链接至标题">¶</a></h2>
<p>尽管Phalcon的解耦性质为我们提供了很大的自由度和灵活性，也许我们只是单纯的想使用它作为一个全栈框架。
为了达到这点，框架提供了变种的 Phalcon\DI 叫 Phalcon\DI\FactoryDefault 。这个类会自动注册相应的服务，并捆绑在一起作为一个全栈框架。</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="nv">$di</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Phalcon\DI\FactoryDefault</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="service-name-conventions">
<h2>服务名称约定（Service Name Conventions）<a class="headerlink" href="#service-name-conventions" title="永久链接至标题">¶</a></h2>
<p>尽管你可以用你喜欢的名字来注册服务，但是Phalcon有一些命名约定，这些约定让你在需要的时候，可以获得正确的（内置）服务。</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="24%" />
<col width="54%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">服务名称</th>
<th class="head">介绍</th>
<th class="head">默认</th>
<th class="head">是否是shared服务</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>dispatcher</td>
<td>控制器调度服务</td>
<td><a class="reference internal" href="../api/Phalcon_Mvc_Dispatcher.html"><em>Phalcon\Mvc\Dispatcher</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>router</td>
<td>路由服务</td>
<td><a class="reference internal" href="../api/Phalcon_Mvc_Router.html"><em>Phalcon\Mvc\Router</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>url</td>
<td>URL生成服务</td>
<td><a class="reference internal" href="../api/Phalcon_Mvc_Url.html"><em>Phalcon\Mvc\Url</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>request</td>
<td>HTTP 请求环境服务</td>
<td><a class="reference internal" href="../api/Phalcon_Http_Request.html"><em>Phalcon\Http\Request</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>response</td>
<td>HTTP响应环境服务</td>
<td><a class="reference internal" href="../api/Phalcon_Http_Response.html"><em>Phalcon\Http\Response</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>cookies</td>
<td>HTTP Cookie管理服务</td>
<td><a class="reference internal" href="../api/Phalcon_Http_Response_Cookies.html"><em>Phalcon\Http\Response\Cookies</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>filter</td>
<td>输入过滤服务</td>
<td><a class="reference internal" href="../api/Phalcon_Filter.html"><em>Phalcon\Filter</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>flash</td>
<td>闪现信息服务</td>
<td><a class="reference internal" href="../api/Phalcon_Flash_Direct.html"><em>Phalcon\Flash\Direct</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>flashSession</td>
<td>闪现session信息服务</td>
<td><a class="reference internal" href="../api/Phalcon_Flash_Session.html"><em>Phalcon\Flash\Session</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>session</td>
<td>session服务</td>
<td><a class="reference internal" href="../api/Phalcon_Session_Adapter_Files.html"><em>Phalcon\Session\Adapter\Files</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>eventsManager</td>
<td>事件管理服务</td>
<td><a class="reference internal" href="../api/Phalcon_Events_Manager.html"><em>Phalcon\Events\Manager</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>db</td>
<td>底层数据库连接服务</td>
<td><a class="reference internal" href="../api/Phalcon_Db.html"><em>Phalcon\Db</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>security</td>
<td>安全助手</td>
<td><a class="reference internal" href="../api/Phalcon_Security.html"><em>Phalcon\Security</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>crypt</td>
<td>加密/解密数据</td>
<td><a class="reference internal" href="../api/Phalcon_Crypt.html"><em>Phalcon\Crypt</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>tag</td>
<td>HTML生成助手</td>
<td><a class="reference internal" href="../api/Phalcon_Tag.html"><em>Phalcon\Tag</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>escaper</td>
<td>内容(HTML)转义</td>
<td><a class="reference internal" href="../api/Phalcon_Escaper.html"><em>Phalcon\Escaper</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>annotations</td>
<td>注释分析器</td>
<td><a class="reference internal" href="../api/Phalcon_Annotations_Adapter_Memory.html"><em>Phalcon\Annotations\Adapter\Memory</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>modelsManager</td>
<td>model管理服务</td>
<td><a class="reference internal" href="../api/Phalcon_Mvc_Model_Manager.html"><em>Phalcon\Mvc\Model\Manager</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>modelsMetadata</td>
<td>model元数据服务</td>
<td><a class="reference internal" href="../api/Phalcon_Mvc_Model_MetaData_Memory.html"><em>Phalcon\Mvc\Model\MetaData\Memory</em></a></td>
<td>是</td>
</tr>
<tr class="row-odd"><td>transactionManager</td>
<td>model事务管理服务</td>
<td><a class="reference internal" href="../api/Phalcon_Mvc_Model_Transaction_Manager.html"><em>Phalcon\Mvc\Model\Transaction\Manager</em></a></td>
<td>是</td>
</tr>
<tr class="row-even"><td>modelsCache</td>
<td>model的缓存服务</td>
<td>None</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>viewsCache</td>
<td>view的缓存服务</td>
<td>None</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="implementing-your-own-di">
<h2>自定义注入器（Implementing your own DI）<a class="headerlink" href="#implementing-your-own-di" title="永久链接至标题">¶</a></h2>
<p>如果你要创建一个自定义注入器或者继承一个已有的，接口 <a class="reference internal" href="../api/Phalcon_DiInterface.html"><em>Phalcon\DiInterface</em></a> 必须被实现。</p>
</div>
</div>


                    </div>
                  </div>
                </div>
            </div>
          </td>
        </tr>
      </table>
    <div class="related">
      <ul>
        <li class="right" >
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="mvc.html" title="MVC 架构（The MVC Architecture）"
             >下一页</a> |</li>
        <li class="right" >
          <a href="samples.html" title="示例列表（List of examples）"
             >上一页</a> |</li> 
      </ul>
    </div>
        <div id="footer">

          <p>Found a typo or an error? Want to improve this document? The documentation sources are available on <a href="http://github.com/phalcon/docs">Github</a></p>
          <p>Need support or have questions? Check our <a href="http://phalconphp.com/support">Support Page</a></p>

          <p>The Phalcon PHP Framework is released under the <a href="https://github.com/phalcon/cphalcon/blob/master/docs/LICENSE.md">new BSD license</a>.</p>
          <p>Except where otherwise noted, content on this site is licensed under the
            <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License.</a></p>
             最后更新于 Mar 10, 2015.
            Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b3.

          <p>
             &copy; 版权所有 2014, Phalcon Team and contributors.
          </p>

            <div class="size-wrap footer-wrap">

                <div class="donate-wrap">
                    Donate to Phalcon: <a href="http://flattr.com/thing/1134206/Phalcon-PHP-Framework" target="_blank" class="button button-small orange">Flattr</a>
                    or
                    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" style="display: inline">
                        <input type="hidden" name="cmd" value="_s-xclick">
                        <input type="hidden" name="hosted_button_id" value="7LSYMNMFZNG8W">
                        <input class="button button-small orange" style="border: inherit; display: inline; font-weight: bold" type="submit" value="via Paypal" title="PayPal — The safer, easier way to pay online.">
                    </form>
                </div>

                <div class="social-links">
                    <a href="https://twitter.com/phalconphp" class="social-link tw">Twitter</a>
                    <a href="http://www.facebook.com/pages/Phalcon/134230726685897" class="social-link fb">Facebook</a>
                    <a href="https://plus.google.com/102376109340560896457" class="social-link gp">Google Plus</a>
                    <a href="http://vimeo.com/user10964377" class="social-link vm">Vimeo</a>
                </div>

            </div>

        </div>

    </div>
    <script type="text/javascript">
    /*$(window).on("load", function(){
      var cx = '009733439235723428699:lh9ltjgvdz8';
      var gcse = document.createElement('script');
      gcse.type = 'text/javascript';
      gcse.async = true;
      gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(gcse, s);
      window.setTimeout(function(){
        $('.gsc-search-button').css({
          'background': '#f06715',
          'padding': '2px',
          'border': '0'
        });
      }, 1000)
    });*/
    </script>

  </body>
</html>